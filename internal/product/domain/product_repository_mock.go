// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package domain

import (
	"context"
	"sync"
)

// Ensure, that ProductRepositoryMock does implement ProductRepository.
// If this is not the case, regenerate this file with moq.
var _ ProductRepository = &ProductRepositoryMock{}

// ProductRepositoryMock is a mock implementation of ProductRepository.
//
//	func TestSomethingThatUsesProductRepository(t *testing.T) {
//
//		// make and configure a mocked ProductRepository
//		mockedProductRepository := &ProductRepositoryMock{
//			CreateProductFunc: func(ctx context.Context, product CreateProductDTO) error {
//				panic("mock out the CreateProduct method")
//			},
//			GetProductsFunc: func(ctx context.Context, filters ProductsFilters) ([]Product, error) {
//				panic("mock out the GetProducts method")
//			},
//		}
//
//		// use mockedProductRepository in code that requires ProductRepository
//		// and then make assertions.
//
//	}
type ProductRepositoryMock struct {
	// CreateProductFunc mocks the CreateProduct method.
	CreateProductFunc func(ctx context.Context, product CreateProductDTO) error

	// GetProductsFunc mocks the GetProducts method.
	GetProductsFunc func(ctx context.Context, filters ProductsFilters) ([]Product, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateProduct holds details about calls to the CreateProduct method.
		CreateProduct []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Product is the product argument value.
			Product CreateProductDTO
		}
		// GetProducts holds details about calls to the GetProducts method.
		GetProducts []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Filters is the filters argument value.
			Filters ProductsFilters
		}
	}
	lockCreateProduct sync.RWMutex
	lockGetProducts   sync.RWMutex
}

// CreateProduct calls CreateProductFunc.
func (mock *ProductRepositoryMock) CreateProduct(ctx context.Context, product CreateProductDTO) error {
	if mock.CreateProductFunc == nil {
		panic("ProductRepositoryMock.CreateProductFunc: method is nil but ProductRepository.CreateProduct was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Product CreateProductDTO
	}{
		Ctx:     ctx,
		Product: product,
	}
	mock.lockCreateProduct.Lock()
	mock.calls.CreateProduct = append(mock.calls.CreateProduct, callInfo)
	mock.lockCreateProduct.Unlock()
	return mock.CreateProductFunc(ctx, product)
}

// CreateProductCalls gets all the calls that were made to CreateProduct.
// Check the length with:
//
//	len(mockedProductRepository.CreateProductCalls())
func (mock *ProductRepositoryMock) CreateProductCalls() []struct {
	Ctx     context.Context
	Product CreateProductDTO
} {
	var calls []struct {
		Ctx     context.Context
		Product CreateProductDTO
	}
	mock.lockCreateProduct.RLock()
	calls = mock.calls.CreateProduct
	mock.lockCreateProduct.RUnlock()
	return calls
}

// GetProducts calls GetProductsFunc.
func (mock *ProductRepositoryMock) GetProducts(ctx context.Context, filters ProductsFilters) ([]Product, error) {
	if mock.GetProductsFunc == nil {
		panic("ProductRepositoryMock.GetProductsFunc: method is nil but ProductRepository.GetProducts was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Filters ProductsFilters
	}{
		Ctx:     ctx,
		Filters: filters,
	}
	mock.lockGetProducts.Lock()
	mock.calls.GetProducts = append(mock.calls.GetProducts, callInfo)
	mock.lockGetProducts.Unlock()
	return mock.GetProductsFunc(ctx, filters)
}

// GetProductsCalls gets all the calls that were made to GetProducts.
// Check the length with:
//
//	len(mockedProductRepository.GetProductsCalls())
func (mock *ProductRepositoryMock) GetProductsCalls() []struct {
	Ctx     context.Context
	Filters ProductsFilters
} {
	var calls []struct {
		Ctx     context.Context
		Filters ProductsFilters
	}
	mock.lockGetProducts.RLock()
	calls = mock.calls.GetProducts
	mock.lockGetProducts.RUnlock()
	return calls
}
